/**
 * 1. 确认动机
 *    - 是否有重复使用场景
 *    - 当前问题是否适合通过封装组件解决
 *    - 是否能降低耦合 / 提升复用 / 抽象通用逻辑
 *
 * 2. 分析边界
 *    - 明确职责：组件要做什么，不做什么（输入/输出）
 *    - 适用场景：在哪些页面、哪些业务逻辑中适用
 *    - 技术约束：框架版本、依赖库、环境限制（PC/H5、小程序）
 *
 * 3. 设计接口
 *    - Props（属性）：传参清晰、可配置性强、设置默认值
 *    - Slots（插槽）：是否需要自定义渲染区域
 *    - Emits（事件）：暴露哪些事件给父组件监听
 *    - Expose（方法暴露）：是否需要向外暴露组件内部方法
 *    - 可扩展性设计：考虑未来可能的变化（例如通过配置项扩展）
 *
 * 4. 代码实现
 *    - 编码风格：统一风格、命名规范、模块清晰
 *    - 状态管理：props、内部状态、双向绑定是否合理
 *    - 解耦性强：依赖最小化，避免强耦合其他业务
 *    - 类型定义（TypeScript）：确保 IDE 智能提示、编译校验
 *    - 国际化（i18n）：是否支持多语言文本
 *    - 主题样式支持：是否支持自定义样式或主题切换
 *    - 可访问性（a11y）：是否符合无障碍规范
 *
 * 5. 功能测试
 *    - 单元测试（Unit Test）：对核心逻辑做精细验证
 *    - 集成测试（Integration Test）：与外围交互部分进行验证
 *    - 手动测试：视觉/交互/动画效果确认
 *    - 本地 CI/CD 模拟：验证打包/构建过程是否通过
 *
 * 6. 发布部署
 *    - 发布目标：项目内部 npm 仓库、公司私有库、开源 npm
 *    - 构建打包：按需引入支持（ESM/CJS/UMD）
 *    - 版本控制：语义化版本（semver）
 *    - 使用文档：使用说明、示例代码、API 文档
 *    - 变更日志：更新记录（CHANGELOG.md）
 *
 * 7. 维护升级
 *    - 监听需求变动：功能扩展或迭代更新
 *    - 兼容性处理：旧版本兼容策略
 *    - 性能优化：缓存、懒加载、虚拟滚动等手段
 *    - 安全漏洞修复：依赖库更新
 *    - 技术栈演进适配：如 Vue2 ➝ Vue3、React ➝ Preact 等
 *
 * 8. 复用策略（建议补充）
 *    - 是否支持组合式使用（如 Hook 或 composable）
 *    - 是否支持局部引入（按需加载）
 *    - 是否可以通过配置项进行功能裁剪或扩展
 *    - 提供统一的组件注册方式（如 install 方法 / 插件机制）
 *
 * 9. 团队协作
 *    - 多人协作开发时的 PR / Code Review 流程
 *    - 统一 lint / format / commit 规范（如 ESLint、Prettier、commitlint）
 *    - 文档协作与更新同步（Storybook、Docsify 等）
 */



/**
 *  封装组件  就是一堆逻辑功能的聚合   我们要把逻辑功能进行抽象和封装 供外部使用
 *
 * 外观模式 （Facade Pattern）又叫门面模式，定义一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的外观。
 * 外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松地使用子系统。本质是封装交互，简化调用。
 *
 * 怎么减少耦合?  让外部调用者只需要关注组件的输入和输出，而不需要了解组件内部的实现细节。
 *
 *  eggjs  koa 中的 controller    util中的封装函数
 *
 *
 *
 *
 *
 * 外观模式的优点：
 * 访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的使用变得简单，符合最少知识原则，增强了可移植性和可读性；
 * 减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性；
 * 通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性；
 *
 * https://interview.amazingxia.top/docs/base/design-pattern.html#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F
 * 外观模式的缺点：
 * 不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口；
 * 不需要或不合理的使用外观会让人迷惑，过犹不及；
 *
 *
 *  9种前端常见的设计模式
 *  https://interview.amazingxia.top/docs/base/improve.html#%E5%8D%81%E4%B8%80%E3%80%819%E7%A7%8D%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */



