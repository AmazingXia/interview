/**
 * 1. 确认动机
 *    - 是否有重复使用场景
 *    - 当前问题是否适合通过封装组件解决
 *    - 是否能降低耦合 / 提升复用 / 抽象通用逻辑
 *
 * 2. 分析边界
 *    - 明确职责：组件要做什么，不做什么（输入/输出）
 *    - 适用场景：在哪些页面、哪些业务逻辑中适用
 *    - 技术约束：框架版本、依赖库、环境限制（PC/H5、小程序）
 *
 * 3. 设计接口
 *    - Props（属性）：传参清晰、可配置性强、设置默认值
 *    - Slots（插槽）：是否需要自定义渲染区域
 *    - Emits（事件）：暴露哪些事件给父组件监听
 *    - Expose（方法暴露）：是否需要向外暴露组件内部方法
 *    - 可扩展性设计：考虑未来可能的变化（例如通过配置项扩展）
 *
 * 4. 代码实现
 *    - 编码风格：统一风格、命名规范、模块清晰
 *    - 状态管理：props、内部状态、双向绑定是否合理
 *    - 解耦性强：依赖最小化，避免强耦合其他业务
 *    - 类型定义（TypeScript）：确保 IDE 智能提示、编译校验
 *    - 国际化（i18n）：是否支持多语言文本
 *    - 主题样式支持：是否支持自定义样式或主题切换
 *    - 可访问性（a11y）：是否符合无障碍规范
 *
 * 5. 功能测试
 *    - 单元测试（Unit Test）：对核心逻辑做精细验证
 *    - 集成测试（Integration Test）：与外围交互部分进行验证
 *    - 手动测试：视觉/交互/动画效果确认
 *    - 本地 CI/CD 模拟：验证打包/构建过程是否通过
 *
 * 6. 发布部署
 *    - 发布目标：项目内部 npm 仓库、公司私有库、开源 npm
 *    - 构建打包：按需引入支持（ESM/CJS/UMD）
 *    - 版本控制：语义化版本（semver）
 *    - 使用文档：使用说明、示例代码、API 文档
 *    - 变更日志：更新记录（CHANGELOG.md）
 *
 * 7. 维护升级
 *    - 监听需求变动：功能扩展或迭代更新
 *    - 兼容性处理：旧版本兼容策略
 *    - 性能优化：缓存、懒加载、虚拟滚动等手段
 *    - 安全漏洞修复：依赖库更新
 *    - 技术栈演进适配：如 Vue2 ➝ Vue3、React ➝ Preact 等
 *
 * 8. 复用策略（建议补充）
 *    - 是否支持组合式使用（如 Hook 或 composable）
 *    - 是否支持局部引入（按需加载）
 *    - 是否可以通过配置项进行功能裁剪或扩展
 *    - 提供统一的组件注册方式（如 install 方法 / 插件机制）
 *
 * 9. 团队协作
 *    - 多人协作开发时的 PR / Code Review 流程
 *    - 统一 lint / format / commit 规范（如 ESLint、Prettier、commitlint）
 *    - 文档协作与更新同步（Storybook、Docsify 等）
 */
